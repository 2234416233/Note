# 匹配ip地址

ip地址是用3个'.'号作为分隔符，分割4个数字，每个数字的取值在[0,255]，一般日志文件中的ip地址都是有效的ip地址，不需要我们再去验证，因此，若从日志文件中提取ip，那么可以简单写成这样：

```python
>>> import re
>>> s='kkk 192.168.1.136 kkk 192.168.1.137 kk 192.168.1.138 kk'
>>> l=re.findall(r'\d+.\d+.\d+.\d+', s)
>>> print l
['192.168.1.136', '192.168.1.137', '192.168.1.138']
```


如果s中的ip地址有可能是无效的，那我们就需要在匹配的过程中，增加判断是否有效的操作，
正确的ip地址是以'.'作为分隔符，如果以','或者其他的字符作为分隔符是不对的，因此我们需要对分隔符进行验证：

```python
>>> s='kkk 192,168,1,136 kkk 192.168.1.137 kk 192.168.1.138 kk' #第一个ip地址以','作为分隔符，这是无效的ip地址
>>> l=re.findall(r'\d+.\d+.\d+.\d+', s)# '.'能够匹配除了'\n'之外的任意一个字符（因此'.'可以匹配上','）
>>> print l
['192,168,1,136', '192.168.1.137', '192.168.1.138'] #显然，第一个ip地址无效
>>> l=re.findall(r'\d+\.\d+\.\d+\.\d+',s)  # '\.'可以精确的匹配'.'
>>> print l
['192.168.1.137', '192.168.1.138']
```



ip地址中每个数字的取值在[0,255]，因此需要验证每个数字的取值对否有效：

```python
>>> s='kkk 192.168.1.336 kkk 192.168.1.137 kk 192.168.1.138 kk'
>>> l=re.findall(r'\d+\.\d+\.\d+\.\d+',s) #并没有验证每个数字的大小，导致第一个错误的ip地址也匹配上了
>>> print l
['192.168.1.336', '192.168.1.137', '192.168.1.138'] #第一个ip地址是无效的，但错误的匹配上了
```



下面的匹配方法可以验证数字的大小：

```python
>>> s='kkk 192.288.1.136 kkk 192.168.1.137 kk 192.168.1.138 kk'
>>> l=re.findall(r'(?:25[0-5]\.|2[0-4]\d\.|[01]?\d\d?\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)',s)
>>> print l
['192.168.1.137', '192.168.1.138']
#或者这样：
>>> l=re.findall(r'(?:(?:25[0-5]|2[0-4]\d|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)',s)
>>> print l
['192.168.1.137', '192.168.1.138']
```

但是上述匹配在下面的情况下依然会出错：（ip地址中超出范围的数字是该ip地址最后一个或第一个）

```python
>>> s='kkk 192.137.1.336 kkk 1192.168.1.137 kk 192.168.1.138 kk' #第一个和第二个ip地址都无效，不应该匹配出来
>>> l=re.findall(r'(?:25[0-5]\.|2[0-4]\d\.|[01]?\d\d?\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)',s)
>>> print l
['192.137.1.33', '192.168.1.137', '192.168.1.138']#截取了第一个和第二个ip地址的一部分
```



这时应如何解决呢？下面是匹配ip地址的常用版本1：

```python
>>> s='kkk 192.137.1.336 kkk 1192.168.1.137 kk 192.168.1.138 kk'
>>> l=re.findall(r'\b(?:25[0-5]\.|2[0-4]\d\.|[01]?\d\d?\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\b',s)
>>> l
['192.168.1.138']
>>> l=re.findall(r'\b(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\b',s)
>>> l
['192.168.1.138']
# '\b'表示符合要求的子串的第一个字符的前面和最后一个字符的后面不可以是'\w'字符（不可以是大小字母，数字，下划线）
#上述版本比较常用，但也存在一点问题：
>>> s='kkk 192.137.1.336 kkk 192.168.1.137.123 kk 192.168.1.138 kk'  
#第二个ip地址以'.'号作为分隔符，且每个数字在[0,255]之间，但该ip地址无效（多了一个数字）！！
>>> l=re.findall(r'\b(?:25[0-5]\.|2[0-4]\d\.|[01]?\d\d?\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\b',s)
>>> print l
['192.168.1.137', '192.168.1.138'] #将第二个ip地址，截取了前4个数字，但显然第二个ip地址本应是无效的！！
```


这种情况可这样解决，使用常用版本2：

```python
>>> s='kkk 192.137.1.336 kkk 192.168.1.137.123 kk 192.168.1.138 kk'
>>> l=re.findall(r'(?<![\.\d])(?:25[0-5]\.|2[0-4]\d\.|[01]?\d\d?\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)(?![\.\d])',s)
>>> print l
['192.168.1.138'] #准确的提取了ip地址！
```

综上所述：
1》若从日志文件中提取ip，那么可以简单写成这样：

```python
re.findall(r'\d+\.\d+\.\d+\.\d+',s)  # 适用于不需要验证ip地址的场合
```

2》如需要验证ip地址，一般使用下面2种方法：

```python
#2.1>
re.findall(r'\b(?:25[0-5]\.|2[0-4]\d\.|[01]?\d\d?\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\b',s)
#或：
re.findall(r'\b(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\b',s)
#2.2>
re.findall(r'(?<![\.\d])(?:25[0-5]\.|2[0-4]\d\.|[01]?\d\d?\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)(?![\.\d])',s)
#或:
re.findall(r'(?<![\.\d])(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)(?![\.\d])',s)
```